// ==============================================================================
// Vector / Dynamic Array - 对应 LLM Inference 中的 KV Cache, Tensor
// ==============================================================================
//
// 【对应引擎模块】
//   - KV Cache: 存储每个 token 的 key/value 向量
//   - Tensor: 多维数组的底层存储
//
// 【学习重点】
//   1. 连续内存布局：所有元素在内存中连续存储，cache-friendly
//   2. 扩容机制：当容量不足时如何进行 2x 扩容（malloc -> memcpy -> free）
//   3. Stride (步长) 访问：模拟 Tensor 的多维访问模式
//
// 【实现要求】
//   - 实现 push_back, pop_back, operator[], resize 等核心操作
//   - 支持 stride 访问：给定起始位置和步长，返回指定元素
//   - 测试扩容时的性能和内存拷贝开销
//
// 【练习目标】
//   - 深入理解连续内存的优势（SIMD、预取）
//   - 掌握动态扩容的 amortized O(1) 复杂度分析
//   - 模拟 vLLM 中 KV Cache 的内存管理
// ==============================================================================

#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>

// ==============================================================================
// 【Phase 3: C++ 语法教学 - 模板泛型 Vector】
// 【填空练习：你来实现，我来指导】
// ==============================================================================

// 任务1：用 template 关键字定义泛型类
// 语法解释：
// - template <typename T> 告诉编译器这是一个模板，可以接受任何类型 T
// - 就像 Python 的 class Vector，但 T 可以是 int, float, 甚至自定义类型
// - 这就是 C++ 的"泛型"特性，让代码可以复用

template <typename T>
class Vector {
private:
    // 任务2：声明三个私有成员变量
    // 语法解释：
    // - T* data 指向连续内存的指针（相当于 Python 的 list）
    // - size_t size_ 当前元素数量（下划线避免和方法名冲突）
    // - size_t capacity_ 当前容量
    // 提示：size_t 是无符号整数，专门用于数组大小和索引

    // 在这里填写三个私有变量声明：
    // T* _______;
    // size_t _______;
    // size_t _______;

public:
    // ==============================================================================
    // 【构造函数 - 初始化内存】
    // ==============================================================================

    // 任务3：实现默认构造函数
    // 语法解释：
    // - Vector() : 这是构造函数，没有返回类型，名字和类名一样
    // - 初始化列表 : data(nullptr), size_(0), capacity_(0)
    //   * nullptr 相当于 Python 的 None，表示空指针
    //   * size_t 是无符号整数类型，专门用于大小/索引

    // 在这里实现默认构造函数：
    // Vector() : __________(nullptr), __________(0), __________(0) {}

    // 任务4：实现带初始容量的构造函数
    // 语法解释：
    // - explicit 防止隐式转换（比如 int -> Vector）
    // - new T[initial_capacity] 分配连续内存，就像 malloc 但有类型安全
    // 初始化列表：size_(0), capacity_(initial_capacity)

    // 在这里实现带参数构造函数：
    // Vector(size_t initial_capacity) : __________(0), __________(initial_capacity) {
    //     // 你的代码：分配内存给 data
    //     _________ = new _________[__________];
    // }

    // ==============================================================================
    // 【析构函数 - 释放内存】
    // ==============================================================================

    // 任务5：实现析构函数
    // 语法解释：
    // - ~Vector() 是析构函数，对象销毁时自动调用
    // - delete[] data 释放数组内存（和 new[] 配对使用）
    // - 没有这步就会内存泄漏！

    // 在这里实现析构函数：
    // ~Vector() {
    //     // 你的代码：释放内存
    //     ___________ _________;
    // }

    // ==============================================================================
    // 【核心方法 - 按照 Python 逻辑蓝图实现】
    // ==============================================================================

    // 任务6：实现 size() 方法
    // 语法解释：返回当前元素数量，const 表示不会修改对象
    // 在这里实现：size_t size() const { return _________; }

    // 任务7：实现 capacity() 方法
    // 语法解释：返回当前容量，const 表示不会修改对象
    // 在这里实现：size_t capacity() const { return _________; }

    // 任务8：实现 push_back
    // 按照 Python 逻辑蓝图：
    // 步骤 1: 检查是否需要扩容（size_ >= capacity_）
    // 步骤 2: 如果需要，计算新容量（capacity_ == 0 ? 1 : capacity_ * 2），调用 resize
    // 步骤 3: 把 value 放到 data[size_] 位置
    // 步骤 4: size_ 加 1

    // 在这里实现 push_back：
    // void push_back(const T& value) {
    //     if (_________ >= _________) {
    //         size_t new_capacity = (_________ == 0) ? 1 : _________ * 2;
    //         _________(new_capacity);
    //     }
    //     _________[_________] = value;
    //     _________++;
    // }

    // 任务9：实现 pop_back
    // 按照逻辑蓝图：
    // 步骤 1: 检查是否为空（size_ == 0）
    // 步骤 2: 如果为空，抛出异常 std::out_of_range("Vector is empty")
    // 步骤 3: size_ 减 1
    // 步骤 4: 返回 data[size_] 的值（注意：size_ 已经减 1 了）

    // 在这里实现 pop_back：
    // T pop_back() {
    //     if (_________ == 0) {
    //         throw std::__________("Vector is empty");
    //     }
    //     _________--;
    //     return _________[_________];
    // }

    // 任务10：实现 operator[] 重载（下标访问）
    // 语法解释：
    // - T& operator[](size_t index) 让 v[0] 可以工作
    // - 返回引用 & 意味着可以修改：v[0] = 5
    // - 需要检查索引是否有效

    // 在这里实现 operator[]：
    // T& operator[](size_t index) {
    //     if (_________ >= _________) {
    //         throw std::__________("Index out of range");
    //     }
    //     return _________[_________];
    // }

    // 任务11：实现 const 版本的 operator[]
    // 语法解释：让 const 对象也能用下标访问
    // const T& operator[](size_t index) const { /* 类似上面的实现 */ }

    // 任务12：实现 resize 方法
    // 按照逻辑蓝图：
    // 步骤 1: 分配新的数组 T* new_data = new T[new_capacity];
    // 步骤 2: 复制旧数据 for (size_t i = 0; i < size_; ++i) new_data[i] = data[i];
    // 步骤 3: 释放旧数组 delete[] data;
    // 步骤 4: 更新指针和容量 data = new_data; capacity_ = new_capacity;

    // 在这里实现 resize：
    // void resize(size_t new_capacity) {
    //     T* _________ = new _________[__________];
    //
    //     // 复制现有元素
    //     for (size_t i = 0; i < _________; ++i) {
    //         _________[i] = _________[i];
    //     }
    //
    //     // 释放旧内存
    //     ___________ _________;
    //
    //     // 更新指针和容量
    //     _________ = _________;
    //     _________ = _________;
    // }

    // 任务13：实现 stride 访问（模拟 Tensor 多维访问）
    // 语法解释：
    // - std::vector<T> 是 C++ 标准库的动态数组
    // - 从 start_index 开始，每次跳 stride 步
    // - 返回所有访问到的元素

    // 在这里实现 stride（这是高级功能，可以最后做）：
    // std::vector<T> stride(size_t start_index, int stride) const {
    //     // 检查参数有效性
    //     if (_________ >= _________) {
    //         throw std::__________("Start index out of range");
    //     }
    //     if (_________ == 0) {
    //         throw std::__________("Stride cannot be zero");
    //     }
    //
    //     std::vector<T> result;
    //     size_t current_index = _________;
    //
    //     if (_________ > 0) {
    //         // 正向步进
    //         while (_________ < _________) {
    //             result.push_back(_________[__________]);
    //             _________ += _________;
    //         }
    //     } else {
    //         // 负向步进 - 这个比较复杂，可以暂时跳过
    //         // TODO: 实现负stride逻辑
    //     }
    //
    //     return result;
    // }
};

// ==============================================================================
// 【测试代码框架 - 你来填内容】
// ==============================================================================

int main() {
    std::cout << "=== C++ Vector Template Test ===\n";

    // 任务14：创建 Vector 实例并测试基本功能
    // 提示：
    // - Vector<int> v(4); 创建容量为4的int Vector
    // - 测试 push_back, pop_back, operator[]
    // - 测试扩容（添加超过4个元素）
    // - 测试不同类型：Vector<std::string>

    // 你的测试代码写在这里：
    // Vector<int> v(4);
    // std::cout << "初始状态: size=" << v.size() << ", capacity=" << v.capacity() << "\n";

    return 0;
}

// ==============================================================================
// 【Phase 4: vLLM 连接 - 填完代码后我们来聊】
// ==============================================================================

/*
等你填完代码并成功编译运行后，我们来聊聊：

【vLLM 中的应用场景】
1. KV Cache 的连续内存布局
2. 动态扩容如何影响推理性能
3. 为什么 C++ 比 Python 快那么多

现在开始填空吧！从任务1开始，一个个来。
遇到问题随时问我，我会一步步指导你。
*/
